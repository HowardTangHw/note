## 20.Decorator(修饰器)

### 20.1类的修饰

许多面向对象的语言都有修饰器(Decorator)函数,用来修改类的行为.目前,有一个[提案](https://github.com/tc39/proposal-decorators)将这项功能，引入了 ECMAScript。

```js
@testable
class MyTestableClass{
  // some code
}

function testable(target) {
  target.isTestable = true;
}

MytestableClass.isTestable //true
```

上面代码中,`@teatable`就是一个修饰器.它修改了`MyTestableClass`这个类的行为,为它加上了静态属性`isTestable`.`testable`函数的参数`target`是`MyTestableClass`类本身.

基本上,修饰器的行为就是下面这样.

```js
@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;
```

也就是说,修饰器是一个队类进行处理的函数.修饰器函数的第一个参数,就是所需要修饰的目标类.

```js
function testable(target){
  //...
}
```

上面代码中,`testable`的参数`target`,就是会被修饰的类。

如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。

```js
function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  }
}

@testable(true)
class MyTestableClass {}
MyTestableCalss.isTestable //true

@testable(false)
class Myclass {}
MyClass.isTestable //false
```

上面代码中,修饰器`testable`可以接受参数,这就等于可以修改修饰器的行为

注意,修饰器对类的行为的改变,是代码编译发生的,而不是运行时,这意味着,修饰器能在编译阶段运行代码,也就是说,修饰器本质就是编译时执行的函数.

前面的例子是为类添加一个静态属性,如果想添加实例属性,可以通过目标类的`prototype`对象操作.

```js
function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();

```




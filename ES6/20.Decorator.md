## 20.Decorator(修饰器)

### 20.1类的修饰

许多面向对象的语言都有修饰器(Decorator)函数,用来修改类的行为.目前,有一个[提案](https://github.com/tc39/proposal-decorators)将这项功能，引入了 ECMAScript。

```js
@testable
class MyTestableClass{
  // some code
}

function testable(target) {
  target.isTestable = true;
}

MytestableClass.isTestable //true
```

上面代码中,`@teatable`就是一个修饰器.它修改了`MyTestableClass`这个类的行为,为它加上了静态属性`isTestable`.`testable`函数的参数`target`是`MyTestableClass`类本身.

基本上,修饰器的行为就是下面这样.

```js
@decorator
class A {}

// 等同于

class A {}
A = decorator(A) || A;
```

也就是说,修饰器是一个队类进行处理的函数.修饰器函数的第一个参数,就是所需要修饰的目标类.

```js
function testable(target){
  //...
}
```

上面代码中,`testable`的参数`target`,就是会被修饰的类。

如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。

```js
function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  }
}

@testable(true)
class MyTestableClass {}
MyTestableCalss.isTestable //true

@testable(false)
class Myclass {}
MyClass.isTestable //false
```

上面代码中,修饰器`testable`可以接受参数,这就等于可以修改修饰器的行为

注意,修饰器对类的行为的改变,是代码编译发生的,而不是运行时,这意味着,修饰器能在编译阶段运行代码,也就是说,修饰器本质就是编译时执行的函数.

前面的例子是为类添加一个静态属性,如果想添加实例属性,可以通过目标类的`prototype`对象操作.

```js
function testable(target) {
  target.prototype.isTestable = true;
}

@testable
class MyTestableClass {}

let obj = new MyTestableClass();
obj.isTestable //true
```

上面代码中,修饰器函数`testable`是在目标类的`prototype`对象上添加属性,因此就可以在实例上调用.

下面是另一个例子.

```js
// mixins.js
export function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype,...list)
  }
}

// main.js
imort { mixins } from './mixins';

const Foo = {
  foo() {console.log('foo')}
};

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo() //'foo'
```

上面代码通过修饰器`mixins`,把`Foo`类的方法添加到`MyClass`的实例上面,可以用`Object.assign()`模拟这个功能

> ps。。不是本身就是用Object.assign来实现的吗..

```js
const Foo = {
  foo() {console.log('foo')};
};

class MyClass {}

Object.assign(MyClass.prototype,Foo);

let obj = new MyClass();
obj.foo() //'foo'
```

实际开发中,React 与 Redux库结合使用时,常常需要写成下面这样.

```js
class MyReactComponent extends React.Component{}

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
```

有了装饰器，就可以改写上面的代码。

```js
@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component {}
```

相对来说，后一种写法看上去更容易理解。



### 20.2 方法的修饰

修饰器不仅可以修饰类,还可以修饰类的属性.

```js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
```

上面代码中,修饰器`readonly`用来修饰`类`的`name`方法.

修饰器函数`readonly`一共可以接受三个参数.

```js
function readonly (target,name,descriptor) {
  // descriptor对象原来的值如下
  // {
  //   value: specifiedFunction,
  //   enumerable: false,
  //   configurable: true,
  //   writable: true
  // };
  descriptor.writable = false;
  return descriptor;
}

readonly(Person.prototype,'name',descriptor);
//类似于
Object.defineProerty(Person.prototype,'name',descriptor);
```

修饰器第一个参数是类的原型,上例是`Person.prototype`,修饰器的本意是要`修饰`类的实例,但是这个时候实例还没有生成,所以只能取修饰原型(这不同于类的修饰,那种情况时`target`参数指的是类本身);第二个参数是索要修饰的属性名,第三个参数是该属性的描述对象,

另外,上面代码说明,修饰器(readonly)会修改属性的描述对象(descriptor),然后被修改的描述对象再用来定义属性.

下面是另一个例子,修改属性描述对象的`enumerable`属性,使得该属性不可以遍历.

```js
class Person {
  @nonenumberable
  get kidCount(){ return this.children.length; }
}

function nonenumberable(target,name,descriptor) {
  descriptor.enumberable = false;
  return descriptor;
}
```

下面的`@log`修饰器,可以起到输出日志的作用.

```js
class Math {
  @log
  add(a,b){
    return a + b;
  }
}

function log(target,name,descriptor) {
  var oldValue = descriptor.value;
  
  descriptor.value = function () {
    console.log(`Calling "${name}" width`,arguments);
    return oldValue.apply(null,arguments);
  }
  
  return descriptor;
}

const math = new Math();

// passed parameters should get logged now
math.add(2,4);
```

上面代码中,`@log`修饰器的作用就是在执行原始的操作之前,执行一次`console.log`,从而达到输出日志的目的.

修饰器有注释的作用.

```js
@testable
class Person {
  @readonly
  @nonenumberable
  name() { return `${this.first} ${this.last}`}
}
```

从上面代码中,我们一眼就可以看出,`Person`类是可测试的,而`name`方法是只读和不可枚举的.

下面是实用Decorator写法的组件,看上去一目了然.

```js
@Component({
  tag:'my-component',
  styleUrl:'my-component.scss'
})
export class MyComponent {
  @Prop() first:string;
  @prop() last:string;
  @State() isVisible: boolean = true;

render() {
  return (`<p>Hello, my name is {this.first} {this.last}</p>`); 
 }
}
```

如果同一个方法有多个修饰器,就会像剥洋葱一样,先从外到内进入,然后由内向外执行.

```js
function dec(id){
  console.log('evaluated',id);
  return (target,property,descriptor) => console.log('executed',id);
}

class Example {
  @dec(1)
  @dec(2)
  method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1
```

上面代码中，外层修饰器`@dec(1)`先进入，但是内层修饰器`@dec(2)`先执行。

除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。



### 20.3 为什么修饰器不能用于函数?

修饰器只能用于类和类的方法,不能用于函数,因为存在函数提升。

```js
var counter = 0;
var add = function (){
  counter ++;
}

@add
function foo(){
}
```

上面的代码,意图是在foo执行后,`counter`等于1,但实际上结果是`counter`等于0,因为函数提升,使得实际执行的代码是下面这样。

```js
@add
function foo(){}

var counter;
var add;

counter = 0;
add = function (){
  counter++;
}
```

下面是另一个例子.

```js
var readOnly = require('some-decorator');

@readOnly
function foo(){
  
}
```

实际执行

```js
var readOnly;

@readOnly
function foo(){
}
readOnly = require('some-decorator');
```

总之,由于存在函数提升,使得修饰器不能用于函数,类是不会提升的,所以就没有这个问题

另一方面,如果一定要修饰函数,可以采用高阶函数的形式直接执行

```js
function doSomething(name){
  console.log('Hello,'+name);
}
function loggingDecorator(wrapped){
  return function () {
    console.log('Starting');
    const result = wrapped.apply(this,arguments);
    console.log('Finished');
    return result;
  }
}

const wrapped = loggingDecorator(doSomething);
```



### 20.4 Core-decorators.js

 [core-decorators.js](https://github.com/jayphelps/core-decorators.js)是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。

1. @autobind

   `autobind`修饰器使得方法中的`this`对象,绑定原始对象

   ```js
   import { autobind } from 'core-decorators';
   class Person {
     @autobind
     getPerson(){
       return this;
     }
   }

   let person = new Preson();
   let getPerson = person.getPerson;

   getPerson() === person; //true  

   //默认情况
   class Person {
     getPerson(){
       return this;
     }
   }

   let person = new Person();
   let getPerson = person.getPerson;
   getPerson() === person.prototype; //true  
   ```

2. @readonly

   `readonly`修饰器使得属性或方法不可写(只读)

   ```js
   import { readonly } from 'core-decorators';

   class Meal {
     @readonly
     entree = 'steak';
   }

   var dinner = new Meal();
   dinner.entree = 'salmon';
   // Cannot assign to read only property 'entree' of [object Object]
   ```

3. @override

   `override`修饰器检查子类的方法,是否正确覆盖了父类的同名方法,如果不正确会报错.

   ```js
   import { override } frome 'core-decorators';

   class Parent {
     speak(first,second){}
   }

   class Child extends Parent {
     @override
     speak(){}
       // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)
   }

   // or

   class Child extends Parent {
     @override
     speaks() {}
     // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.
     //
     //   Did you mean "speak"?
   }
   ```

4. @depreacate (别名@deprecated)

   `deprecate`或`deprecated`修饰器在控制台显示一条警告,表示该方法将废除.

   ```js
   import { deprecate } from 'core-decorators';

   class Person {
     @deprecate
     facepalm(){}
     
     @deprecate('We stopped facepalming')
     facepalmHard(){}
     
     @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })
     facepalmHarder() {}
   }

   let person = new Person();

   person.facepalm();
   // DEPRECATION Person#facepalm: This function will be removed in future versions.

   person.facepalmHard();
   // DEPRECATION Person#facepalmHard: We stopped facepalming

   person.facepalmHarder();
   // DEPRECATION Person#facepalmHarder: We stopped facepalming
   //
   //     See http://knowyourmeme.com/memes/facepalm for more details.
   //
   ```

5. @suppressWarnings

   `supperssWarnings`修饰器抑制`deprecated`修饰器导致的`console.warn()`调用.但是,异步代码发出的调用除外.

   ```js
   import { suppressWarnings } from 'core-decorators';

   class Person {
     @deprecated
     faceplam(){}
     
     @suppressWarnings
     facepalmWithoutWarning() {
       this.facepalm();
     }
   }

   let person = new Person();

   person.facepalmWithoutWarning();
   // no warning is logged
   ```

   ​
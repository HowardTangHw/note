# ES6笔记

> 阮一峰老师写的《ECMAScript 6入门》的笔记..
>
> [ECMAScript 6入门](http://es6.ruanyifeng.com/)

[TOC]



## 1.let和const命令

## 2.变量的结构赋值

## 3.字符串的拓展

## 4.正则的拓展

## 5.数值的拓展

## 6.函数的拓展

## 7.数组的拓展

## 8.对象的拓展

## 9.Symbol

## 10.Set和Map 数据结构

## 11.Proxy(代理)

## 12.Reflect
> 就是将一些Obj上的方法优化,然后放在Reflect下

## 13.Promise 对象
```javascript
var p = new Promeise(function(resolve,reject){
  //...some code
  if(/*操作成功*/){
    resolve(value);
  } else {
    reject(error);
  }
});
```

> then 一般用来处理resolve
> 而catch一般处理reject **因为catch可以将在此之前的错误打印出来,而then第二个参数虽然也可以处理reject,但是一般只能用于处理当前的错误.**

> then和catch返回的是`Promeise的实例` 所以可以链式编程



## 14.Iterator(遍历器)和 for...of 循环

> ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）。`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名`Symbol.iterator`，它是一个表达式，返回`Symbol`对象的`iterator`属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内

- 原生具备 Iterator 接口的数据结构如下。
  + Array
  + Map
  + Set
  + String
  + TypedArray
  + 函数的 arguments 对象

- `for...of`有一些显著的优点。
  + 有着同for...in一样的简洁语法，但是没有for...in那些缺点。
  + 不同于forEach方法，它可以与break、continue和return配合使用。
  + 提供了遍历所有数据结构的统一操作接口。

- `forEach`无法中途跳出forEach循环，break命令或return命令都不能奏效

- `for...in`循环可以遍历数组的键名
  + 数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。
  + `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
  + 某些情况下，`for...in`循环会以任意顺序遍历键名。

## 15.**Generator** 函数的语法
- Generator函数也是一个普通函数,但是有两个特征.
  + `function`关键字与函数名之间有一个星号
  + 函数体内部使用`yield`表达式,定义不同的状态


Generator函数调用和普通方法一样,调用Generator函数后,该函数并不执行,返回的也不是函数执行结果,而是一个指向内部状态的指针对象,也就是遍历器对象(Iterator Object)

下一步必须调用遍历器对象的`next`方法,使得指针指向下一个状态.所以,Generator函数是分段执行的,而`yield`表达式是暂停执行的标记,而`next`方法可以恢复执行.

### 15.1 yield表达式

遍历器对象的next方法的运行逻辑如下。

（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

### 15.2 与Iterator 接口的关系

`对象`没有`Symbol.iterator`接口,所以不能进行`for...of`遍历.

**Generator** 函数就是遍历器生成函数, 因此可以将Generator赋值给`对象`的`Symbol.iterator`属性,从而使得该对象具有**Iterator**接口.

```javascript
var obj = {};
obj[Symbol.iterator] = function* (){
  yield 1;
  yield 2;
  yield 3;
};

[...obj] //[1,2,3]
```


### 15.3 next方法的参数

`yied`表达式本身没有返回值(总是返回`undefined`)

`next`方法可以带一个参数

- **这个参数就会被当作上一个`yield`表达式的返回值.**


> Generator 函数从暂停状态到恢复运行,它的上下文(context)是不变的.通过`next`方法的参数,就有办法在Generator 函数开始运行之后,继续向函数体内部注入值(`就是还可以传参`),作为上一个`yield`表达式的返回值



```javascript
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```


上面代码中,由于a的第二次运行`next`方法的时候不带参数,导致y的值等于`2 * undefined`( 即`NAN` ),然后继续,将`NaN/3`还是`NaN`,第三次运行`Next`方法的时候不带参数，所以z等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。

如果向`next`方法提供参数，返回结果就完全不一样了。上面代码第一次调用`b`的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次`yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

> 由于`next`传参是代表的是上一个`yield`表达式的值,所以第一次调用的时候并不能带参数(没有以上一个`yield`).V8 引擎直接忽略第一次使用`next`方法时的参数，只有从第二次使用`next`方法开始，参数才是有效的。从语义上讲，第一个`next`方法用来启动遍历器对象，所以不用带有参数。

如果想第一次`Next`就传入参数的话,可以在 Generator 函数外面再包一层.(其实就是**返回一个已经执行了第一次`next`的Genrator 函数**)

```javascript
function wrapper(generatorFunction) {
  return function (...args) {
    let generatorObject = generatorFunction(...args);
    generatorObject.next();
    return generatorObject;
  };
}

const wrapped = wrapper(function* () {
  console.log(`First input: ${yield}`);
  return 'DONE';
});

wrapped().next('hello!')
// First input: hello!
```

`yield`也可以作为变量放在`${yield]`中输出
```javascript
function* dataConsumer() {
  console.log('Started');
  console.log(`1. ${yield}`);
  console.log(`2. ${yield}`);
  return 'result';
}

let genObj = dataConsumer();
genObj.next();
// Started
genObj.next('a')
// 1. a
genObj.next('b')
// 2. b
```

### 15.4 for..of  循环

`for...of`循环可以自动遍历 Generator 函数 生成的`Ierator`对象,并且此时不需要调用`next`方法

```javascript
function *foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

> 注意 `return`的时候 返回的是`{value:value,done:true}`,这时`done`为`true`所以循环会中止,且不包含该返回对象,所以`return`不包括在`for..of`的循环当中.

- 斐波那契数列
```javascript
function* fibonacci() {
  let [prev,curr]=[0,1];
  for (;;){
    [prev,curr]=[curr,prev + curr];
    yield curr;
  }
}
for(let v of fibonacci()){
  if(v > 1000) break;
  console.log(v);
}
```

原生的javascript对象没有遍历接口(Iterator),无法使用`for..of`循环,通过 Generator 函数为它加上这个接口，就可以用了。
```javascript
function* objectIterator(obj){
  //获取对象所有的键值数组
  let objKeys = Reflect.ownKeys(obj);

  for(let objKey of objKeys){

    //将值 键值对形式返回
    yield [objkey , obj[objKey]];

  }
}

let jane = { first: 'Jane', last: 'Doe' };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

上面代码中，对象jane原生不具备 Iterator 接口，无法用for...of遍历。这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的`Symbol.iterator`属性上面。


```javascript
function* objectIterator() {
  ////获取对象所有的键值数组
  let objKeys = Object.keys(this);

  for( let objKey of objKeys ){

    //输出键值对
    yield [objKey,this[objKey]];

  }
}

let jane = { first: 'Jane', last: 'Doe' };

jane[Symbol.iterator] = objectIterator;

for (let [key, value] of jane) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```
> 加上`遍历接口(iterator)`后,除了`for...of`循环外,扩展运算符( `...` ),解构赋值和`Array.from`方法内部调用的,都是遍历器接口.这意味着,它们都可以将Generator 函数返回的 Ierator对象,作为参数.

```javascript
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
```


### 15.5 Generator.prototype.throw()

Generator 函数返回的遍历器对象,都有一个`throw`方法,可在函数体外抛出错误,然后在Generator 函数体内捕获.

```javascript
var g =function* (){
  try {
    yield;
  } catch (e){
    console.log('内部捕获',e);
  }
};

var i = g();
i.next();

try{
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获',e);
}
// 内部捕获 a
// 外部捕获 b
```

遍历器对象`i`连续抛出两个错误.第一个错误被Generator函数体内的`catch`语句捕获,`i`第二次抛出错误,由于Generator函数内部的`catch`语句已经执行过了,不会再捕捉到这个错误了,所以这个错误就被抛出了Generator函数体,被`函数体外的catch`语句捕获



`throw`方法可以接受一个参数,该参数会被`catch`语句接收,建议抛出`Error`对象的实例。

```javascript
var g = function* () {
  try{
    yield;
  } catch(e) {
    console.log(e);
  }
};

var i = g();
i.next();
i.throw(new Error('出错了!'));
```

> 不要混淆遍历器对象的`throw`方法和全局的`throw`命令,上面的代码的错误,是由**遍历器对象的`throw`**方法抛出的,而不是全局的`throw`命令抛出的. 全局的`throw`命令只能被函数体外的`catch`语句捕获.

```javascript
var g = function* () {
  while (true) {
    try {
      console.log('1');
      yield;
    } catch(e) {
      console.log('2');
      if (e ! = 'a') throw e; 
      console.log('内部',e);
    }
  }
};

var i = g();
i.next();//1---这里执行了Generator里面的try 但没有抛出错误.所以没有被内部的捕获

try {
  throw new Error('a');//外部& 错误,然后被catch捕获,下面一条一句就不会被捕获了
  throw new Error('b');
} catch(e) {
  console.log('外部',e);
}
```

> 上面代码只捕获了`a`,是因为函数体外的`catch`语句块，捕获了抛出的`a`错误以后，就不会再继续`try`代码块里面剩余的语句了.



如果 Generator 函数内部没有部署`try...catch`代码块，那么`throw`方法抛出的错误，将被外部`try...catch`代码块捕获。

```javascript
var g = function* () {
  while (true) {
    yield;
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  i.throw('a');//注意 这里是i抛出错误
  i.throw('b');//注意 这里是i抛出错误
} catch (e) {
  console.log('外部捕获', e);
}
// 外部捕获 a
```



上面代码中，Generator 函数`g`内部没有部署`try...catch`代码块，所以抛出的错误直接被外部`catch`代码块捕获。

如果 Generator 函数内部和外部，都没有部署`try...catch`代码块，那么程序将报错，直接中断执行。

`throw `方法被捕获以后,会附带执行下一条的`yield`表达式. 也就是说,会执行一次`next`方法.

```javascript
var gen = function* gen(){
  try {
    yield console.log('a');
  } catch (e) {
    // ...
  }
  yield console.log('b');
  yield console.log('c');
}

var g = gen();
g.next() // a
g.throw() // b
g.next() // c
```

上面代码中,`g.throw`方法被捕获以后,自动执行了一次`next`方法,所以会打印`b`.另外,也可以看到,只要Generator函数内部部署了`try...catch`代码块,那么遍历器的`throw`方法抛出的错误,不影响下一次遍历。(就是不会中断)

另外,`throw`命令与`g.throw`方法是无关的.两者不互相影响

```javascript
var gen = function* gen(){
  yield console.log('hello');
  yield console.log('world');
}

var g = gen();
g.next();

try {
  throw new Error();
} catch (e) {
  g.next();
}
// hello
// world
```

上面代码中,`throw`命令抛出的错误不会影响到遍历器的状态,所以两次执行`next`方法,都进行了正确的操作.



这种函数体捕获错误的机制,大大方便了对错误的处理,多个`yield`表达式,可以只用一个`try...catch`来捕获**(因为内部throw之后会执行一次next,而不像全局的`throw`命令,会直接中断程序的执行)**,如果使用回调函数的写法,想要捕获多个错误,就不得不为每个函数内部写一个错误的语句,而使用Generator函数内部只要写一个`catch`语句就OK了



Generator 函数体外抛出错误 可以在函数体内捕获; 反过来, Generator函数体内抛出错误,也可以被函数体外的`catch`捕获.



```
function* foo() {
  var x = yield 3;
  var y = x.toUpperCase();
  yield y;
}

var it = foo();

it.next(); // { value:3, done:false }

try {
  it.next(42);
} catch (err) {
  console.log(err);
}
```

上面代码中，第二个`next`方法向函数体内传入一个参数42，数值是没有`toUpperCase`方法的，所以会抛出一个TypeError错误，被函数体外的`catch`捕获。



一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用`next`方法，将返回一个`value`属性等于`undefined`、`done`属性等于`true`的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。



```
function* g() {
  yield 1;
  console.log('throwing an exception');
  throw new Error('generator broke!');
  yield 2;
  yield 3;
}

function log(generator) {
  var v;
  console.log('starting generator');
  try {
    v = generator.next();
    console.log('第一次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  try {
    v = generator.next();
    console.log('第二次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  try {
    v = generator.next();
    console.log('第三次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  console.log('caller done');
}

log(g());
// starting generator
// 第一次运行next方法 { value: 1, done: false }
// throwing an exception
// 捕捉错误 { value: 1, done: false }
// 第三次运行next方法 { value: undefined, done: true }
// caller done
```
上面代码一共三次运行`next`方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。



### 15.6 Generator.prototype.return();

Generator函数返回的遍历器对象,还有一个`return`方法,可以返回给定的值,并且终结遍历Generator函数.

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next()            //{ value:1,done:false }
g.return('foo') 	//{ value:'foo',done:true }
g.next() 			//{ value:undefined,done:true }
```

遍历器对象`g`调用`return`方法后,返回值`value`属性就是 `return`方法的参数`foo`.这样做以后,Generator函数的遍历就终止了,返回值的`done`属性为`true`,以后再调用next(),`done`属性**总是**返回`true`.



如果`return`方法调用时,不提供参数,则返回值`value`属性为`undefined`

```javascript
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next()            //{ value:1,done:false }
g.return() 	//{ value:undefined,done:true }
```



如果内部有`try...finally`代码块,那么`return`方法会推迟到`finally`代码块执行完再执行.

```javascript
function* numbers() {
  yield 1;
  try {
    yield 2;
    yield 3;
  } finally {
    yield 4;
    yield 5;
  }
  yield 6;
}
var g = numbers();
g.next() // { value: 1, done: false }
g.next() // { value: 2, done: false }
g.return(7) // { value: 4, done: false }
g.next() // { value: 5, done: false }
g.next() // { value: 7, done: true }
```

调用`return`方法后,就跳开其他操作,执行开始执行`finally`代码块,执行完`finally`代码块后,再会执行`return`方法(`done`返回的是true),然后就结束.



### 15.7 yield* 表达式

在Generator函数内部,调用另一个Generator函数,默认情况下是没有效果的.

```javascript
function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yiled 'x';
  foo();
  yield 'y';
}

for (let x of bar()){
  console.log(v);
}
//'x'
//'y'
//没有输出'x''a''b''y'的预期结果
```

`foo`和`bar`都是Generator函数,在`bar`中调用`foo`,是不会有效果的



这时就需要`yield*`表达式,用来在一个Generator函数里执行另一个Generator函数

```javascript
function* foo() {
  yield 'a';
  yield 'b';
}

function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()){
  console.log(v);
}
// "x"
// "a"
// "b"
// "y"
```

再来看一个对比的例子

```javascript
function* inner(){
  yield 'hello';
}

function* outer1(){
  yield 'open';
  yield inner();
  yield 'close';
}

var gen = outer1()
gen.next().value //'open'
gen.next().value // 返回一个遍历器对象
gen.next().value //'close'

function* outer2(){
  yield 'open';
  yield* inner();
  yield 'close';
}

var gen = outer2();
gen.next().value //'open'
gen.next().value //'hello!'
gen.next().value //'close'
```

`outer1`没有使用`yield*`,而`outer2`使用了,所以前者返回的是一个遍历器对象,而后者返回的是遍历器对象的内部的值.



从语法上看,如果`yield`后面跟的是一个遍历器对象,就需要在`yield`表达式后面加上星号,表明它返回的是一个遍历器对象.这就是`yield*`表达式

```javascript
let delegatedIterator = (function* () {
  yield 'hello';
  yield 'bye';
}());

let delegatingIterator = (function* () {
  yield 'Greetings!';
  yield* delegatedIterator;
  yield 'ok,bye';
}());

for (let value of delegatingIterator){
  console.log(value);
}
//'Greetings!"
//'hello'
//'bye'
//'ok,bye'

```

`delegatingIterator`是代理者,`delegatedIterator`是被代理者.由于`yiel* delegatedIterator  `得到的值,是一个遍历器,所以要用星号标识.运行结果就是使用一个遍历器,遍历果个Generator函数,有递归的效果.

`yield*`后面的Generator函数(没有`return`语句时),等同于在Generator函数内部,部署一个`for...of`循环.

```javascript
function* concat(iter1,iter2){
  yield* iter1;
  yield* iter2;
}

//等同于 

function* concat(iter1,iter2) {
	for (var value of iter1 ){
      yield value;
	}
  
  	for (var value of iter2 ){
      yield value;
  	}
}

```

`yield*` 后面的Generator函数(没有`return`语句时),不过是`for...of`的一种简写形式,完全可以用后者代替前者,反之,在有`return`语句的时,则需要用`var value = yield* iterator`的形式来获取`return`语句的值



如果`yield*`后面跟着一个数组,由于数组原生支持遍历器,因此就会遍历数组成员.

```javascript
function* gen(){
  yield* ['a','b','c'];
}

gen().next() //{value:'a',done:false}
gen().next() //{value:'a',done:false}
gen().next() //{value:'a',done:false}
gen().next() //{value:'a',done:false}

```

上面代码中,`yield`命令后面如果不加星号,返回的是整个数组,加了星号就标识返回的是数组的遍历器对象.



任何数据结构只要有Iterator接口,就可以被`yield*`遍历

```javascript
let read = (function* () {
  yield 'hello';
  yield* 'hello';
})();

read.next().value // "hello"
read.next().value // "h"
```

上面代码中，`yield`表达式返回整个字符串，`yield*`语句返回单个字符。因为字符串具有 Iterator 接口，所以被`yield*`遍历。



如果被代理的 Generator函数有`return`语句,那么就可以向代理它的Generator函数返回数据.

```javascript
function* foo() {
  yield 2;
  yield 3;
  return 'foo';
}

function* bar() {
  yield 1;
  var v = yield* foo();
  console.log("v:" +v );
  yield 4;
}

var it = bar ();

it.next()
// {value: 1, done: false}
it.next()
// {value: 2, done: false}
it.next()
// {value: 3, done: false}
it.next();
// "v: foo"
// {value: 4, done: false}
it.next()
// {value: undefined, done: true}
```

因为在函数`foo`中有`return`语句,在执行到return语句时,就会向函数`bar`提供了返回值(而前面的是返回Generator遍历器对象)

```javascript
function* genFuncWithReturn() {
  yield 'a';
  yield 'b';
  return 'The result';
}
function* logReturned(genObj) {
  let result = yield* genObj;
  console.log(result);
}

[...logReturned(genFuncWithReturn())]
// The result
// 值为 [ 'a', 'b' ]

//拆分
function* genFuncWithReturn() {
  yield 'a';
  yield 'b';
  return 'The result';
}
function* logReturned() {
  let result = yield* genFuncWithReturn();
  console.log(result);
}
[...logReturned()]

// The result
// 值为 [ 'a', 'b' ]
```

上面代码,存在两次遍历,第一次是`[...logReturned()]` 会遍历`logReturned()`返回的遍历器对象,第二次是`yield*`语句遍历函数`genFuncWithReturn`返回的遍历器对象。最终表现为扩展运算符遍历函数`genFuncWithReturn`返回的遍历器对象.所以,最后的数据表达式得到的值等于`['a','b']`.但是,函数`genFuncWithReturn`的`return`语句有返回值`The result `,会返回给函数`logReturned`内部的`result`变量,因此最终会有终端输出

> 1. `[...]`遍历logRenturned(),同时logRenturned()遍历`yield* genFuncWithReturn();` 将`yield 'a'` `yield 'b'`执行 输出结果`['a','b']`
> 2. `genFuncWithReturn`中的`return 'The result';` 赋值给`logReturned`中的`result`变量,最终终端输出



`yield*`取出嵌套数组的所有成员

```javascript
function* iterTree(tree){
  if(Array.isArray(tree)){
    for ( let i =0; i<tree.length;i++ ){
        yiled* iterTree(itree[i]);
      }
  } else {
    yield tree;
  }
}

const tree  = ['a', ['b','c'],['d','e']];

for (let x of iterTree(tree)) {
  console.log(x);
}
//a
//b
//c
//d
//e
```

下面是一个稍微复杂的例子，使用`yield*`语句遍历完全二叉树。

```javascript
function Tree(left, label, right) {
  this.left = left;
  this.right = right;
  this.label = label;
}

function make(arr) {
  if (arr.length == 1) return new Tree(null, arr[0], null);
  return new Tree(make(arr[0]), arr[1], make(arr[2]));
}

let tree = make([[["a"], "b", ["c"]], "d", [["e"], "f", ["g"]]]);

//先序
function* firstInorder(tree) {
  if (tree) {
    yield tree.label;
    yield* firstInorder(tree.left);
    yield* firstInorder(tree.right);
  }
}

//中序
function* midInorder(tree) {
  if (tree) {
    yield* midInorder(tree.left);
    yield tree.label;
    yield* midInorder(tree.right);
  }
}

//后序
function* endInorder(tree) {
  if (tree) {
    yield* endInorder(tree.left);
    yield* endInorder(tree.right);
    yield tree.label;
  }
}

var result1 = [];
for (let node of firstInorder(tree)) {
  result1.push(node);
}
var result2 = [];
for (let node of midInorder(tree)) {
  result2.push(node);
}
var result3 = [];
for (let node of endInorder(tree)) {
  result3.push(node);
}
console.log("树:" + tree);
console.log("先序:" + result1);
console.log("中序:" + result2);
console.log("后序:" + result3);
```



### 15.8 作为对象属性的Generator函数

如果一个对象的属性是Generator 函数,可以简写成下面形式

```javascript
let obj = {
  * myGeneratorMethod(){
   /*some code*/ 
  }
};
```

在`myGeneratorMethod`属性前面有一个星号,代表这个属性是一个`Generator`函数

完整形式如下:

```javascript
let obj = {
  myGeneratorMethod : function* () {
    //...some code
  }
};
```



### 15.9 Generator函数的`this`

Genrator 函数总是返回一个遍历器,ES6规定**这个遍历器是Generator函数的实例**,也继承了Generator函数的`prototype`对象上的方法.

```javascript
function* g() {}

g.prototype.hello = function () {
  retrun 'hi!';
};

let obj = g();

obj.instanceof g // true
//object instanceof constructor
// instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
obj.hello //'hi!'
```

Generator函数`g`返回的遍历器`obj`,是`g`的实例,而且继承了 `g.prototype`.但是,如果把`g`当作普通的构造函数,并不会生效,因为`g`返回的总是**遍历器对象**,而不是`this`对象.

```javascript
function* g() {
  this.a = 11;
}
let obj = g();
obj.a //undefined
```

上面代码中，Generator函数`g`在`this`对象上面添加了一个属性`a`，但是`obj`对象拿不到这个属性。

Generator函数也不能跟`new`命令一起用，会报错。

```javascript
function* F(){
  yield this.x = 2;
  yield this.y = 3;
}

new F ()
// TypeError: F is not a constructor
```

那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用`next`方法，又可以获得正常的`this`？

变通方法:arrow_heading_down:

生成一个空对象，使用`call`方法绑定 Generator 函数内部的`this`。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。

```javascript
function* F() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}
var obj = {};
var f = F.call(obj);//这里是内部的指针指向了obj,然后遍历器对象给了f

f.next();  // Object {value: 2, done: false}
f.next();  // Object {value: 3, done: false}
f.next();  // Object {value: undefined, done: true}

obj.a // 1
obj.b // 2
obj.c // 3
```

首先是`F`内部的`this`对象绑定`obj`对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次`next`方法（因为`F`内部有两个`yield`表达式），完成F内部所有代码的运行。这时，所有内部属性都绑定在`obj`对象上了，因此`obj`对象也就成了`F`的实例。



将上方遍历器对象`f`和生成的实例对象`obj`合二为一

一个办法就是将`obj`换成`F.prototype`。(就是将属性放到原型里面去了)

```
function* F() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}
var f = F.call(F.prototype);

f.next();  // Object {value: 2, done: false}
f.next();  // Object {value: 3, done: false}
f.next();  // Object {value: undefined, done: true}

f.a // 1
f.b // 2
f.c // 3
```

再将`F`改成构造函数，就可以对它执行`new`命令了。

```
function* gen() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}

function F() {
  return gen.call(gen.prototype);
}

var f = new F();

f.next();  // Object {value: 2, done: false}
f.next();  // Object {value: 3, done: false}
f.next();  // Object {value: undefined, done: true}

f.a // 1
f.b // 2
f.c // 3

f instanceof gen  //true
gen.prototype.a = 2
f.a //2
//所以说.其实还是将数据放在了原型链当中
```

### 15.10含义

******************************

#### Generator 与状态机

Generator 是实现状态机的最佳结构。比如，下面的`clock`函数就是一个状态机。

```
var ticking = true;
var clock = function() {
  if (ticking)
    console.log('Tick!');
  else
    console.log('Tock!');
  ticking = !ticking;
}
```

上面代码的`clock`函数一共有两种状态（`Tick`和`Tock`），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。

```
var clock = function* () {
  while (true) {
    console.log('Tick!');
    yield;
    console.log('Tock!');
    yield;
  }
};
var c = clock();
c.next();//tick
c.next();//tock
```

上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量`ticking`，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。



#### Generator与协程

协程( coroutine )是一种程序运行的方式.可以理解成"协作的线程"或"协作的函数".协程既可以用单线程实现,也可以用多线程实现. 前者是一种特殊的子例程,后者是一种特殊的线程.

1. 协程与子例程的差异

   传统的"子例程"( subroutine ) 采用堆栈式"后进先出"的执行方式,只有当调用子函数完全执行完毕之后,才会执行父函数,协程与其不同,多个线程( 单线程情况下,即多个函数 ) 可以并行执行,但是只有一个线程(或函数)处于正在运行的状态,其他线程( 或函数 )都处于暂停态(suspended), 线程(或函数) 之间可以交换执行权,也就是说,一个线程(或函数)执行到一半,可以暂停执行,将执行权交给另一个线程( 或函数 ),等到稍后收回执行权的时候,再回复执行.这种可以并行执行,交换执行权的线程( 或函数 ),就称为协程.

   从实现上看,在内存中,子例程只使用一个栈( stack ) ,而协程是同时存在多个栈,但只有一个栈是在运行状态,也就是说,协程是以多占用内存为代价,实现多任务的并行.

2. 协程与普通线程的差异

   协程适合用于多任务运行的环境.在这个意义上,它与普通的线程很相似,都有自己的执行上下文,可以分享全局变量.它们的不同之处在于,同一时间可以有多个线程处于运行状态,但是运行的协程只有一个,其他协程都处于暂停状态.此外,普通线程都是抢先式的,到底哪个线程优先得到资源,必须由运行环境决定,但是协程都是合作式,执行权由协程自己分配.

   由于JavaScript 是单线程语言,只能保持一个调用栈,引入协程之后,每个任务可以保持自己的调用栈,这样做的最大好处,就是抛出错误的时候,可以找到原始的调用栈,不至于像异步操作的回调函数那样,一旦出错,原始的调用栈早就结束了.

   Generator 函数是ES6 对协程的实现,但属于不完全的实现。Generator函数被称为'半协程(semi-coroutine)',意思是只有Generator 函数的调用者,才能将程序的执行权还给Generator函数.如果是完全执行的协程,任何函数都可以让暂停的协程继续执行.

   如果Generator函数当作协程,完全可以将多个需要互相协作的任务写成Generator函数,它们之间使用`yield`表示式交换控制权


### 15.11 应用

Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。

#### 异步操作的同步化表达

Generator 函数的暂停执行的效果，意味着可以把异步操作写在`yield`表达式里面，等到调用`next`方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在`yield`表达式下面，反正要等到调用`next`方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。

```javascript
function* loadUI() {
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
}
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
```

上面代码中，第一次调用`loadUI`函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用`next`方法，则会显示`Loading`界面（`showLoadingScreen`），并且异步加载数据（`loadUIDataAsynchronously`）。等到数据加载完成，再一次使用`next`方法，则会隐藏`Loading`界面。可以看到，这种写法的好处是所有`Loading`界面的逻辑，都被封装在一个函数，按部就班非常清晰。

Ajax 是典型的异步操作,通过Generator函数部署Ajax操作,可以用同步的方式表达.

```javascript
function* main(){
  var result = yield request('//some.url');
  var resp = JSON.parse(result);
  console.log(resp.value);
}

function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}

var it = main();
it.next();

//自己改的

function* main() {
  var result = yield ajaxFnc('www.baidu.com');
  var resp = result;
  console.log(resp);
}

function ajaxFnc(url){
  var a ='callback';
  setTimeout(function(){
    console.log('123')
    it.next(a);//这里的a会作为return 的值传给result ,因为yield表达式本身没有值,总是等于`undefined`
  },0)
}
var it = main();
it.next();
```

上面代码的`main`函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个`yield`，它几乎与同步操作的写法完全一样。注意，`makeAjaxCall`函数中的`next`方法，必须加上`response`参数，因为`yield`表达式，本身是没有值的，总是等于`undefined`。

下面是另一个例子，通过 Generator 函数逐行读取文本文件。

```
function* numbers() {
  let file = new FileReader("numbers.txt");
  try {
    while(!file.eof) {
      yield parseInt(file.readLine(), 10);
    }
  } finally {
    file.close();
  }
}

```

上面代码打开文本文件，使用`yield`表达式可以手动逐行读取文件。

#### 控制流管理

如果有一个多步操作非常耗时,采用回调,就会有可能写成下面这样.

```javascript
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // Do something with value4
      });
    });
  });
});
```

采用Promise改写上面的代码.

```javascript
Promise.resolve(step1)
	.then(step2)
	.then(step3)
	.then(step4)
	.then(fucntion (value4) {
      // Do something with value4
	},function (error) {
      // Handle any error from step1 through step4
	})
    .done();
```

上面代码利用Promise 将回调函数改成了直线执行的形式,但是假如了大量Promise的语法(其实还是回调地狱...所以Promise并不是解决异步的最优方案,`Async/Await`算是目前的终极解决方案,结合了`yield`和`promise`的优点)。Generator 函数可以进一步改善代码运行流程。

```javascript
function* longRunningTask(value1){
  try {
    var value2 = yield step1(value1);
    var value3 = yield step2(value2);
    var value4 = yield step3(value3);
    var value5 = yield step4(value4);
    //...some code
  } catch(e) {
    //Handle any error fome step1 through step4
  }
}
```

然后,使用一个函数,按次序自动执行所有步骤.

```javascript
scheduler(longRunningTask(initialValue));

function scheduler(task) {
  var taskObj = task.next(task.value);
  // 如果Generator函数未结束,就继续调用
  if(!taskObj.done){
    task.value = taskObj.value;
    scheduler(task);
  }
}
```

注意,上面这种做法,只适合同步操作,即所有的`task`都必须同步的,不能有异步操作,因为这里的代码一得到返回值,就继续往下执行,没有判断异步操作何时完成. 

```javascript
let steps = [step1Func,step2Func,step3Func];
function* iteratesSteps(steps){
  for(var i=0; i < steps.length; i++ ){
    var step = steps[i];
    yield step();
  }
}
```

数组`step`封装了一个任务的多个步骤,Generator函数`iterateSteps`则是依次为这些步骤加上了`yield`命令.

将任务分解成步骤之后,还可以将项目分解成多个依次执行的任务

```javascript
let jobs = [job1,job2,job3];

function* iterateJobs(jobs){
  for (var i =0;i<jobs.length;i++){
    var job =jobs[i];
    yield* iterateSteps(job.steps);
  }
}
```

数组`jobs`封装了一个项目的多个任务，Generator 函数`iterateJobs`则是依次为这些任务加上`yield*`命令。然后执行上面的`iterateSteps` 将每一个任务的多个步骤依次执行.

最后，就可以用`for...of`循环一次性依次执行所有任务的所有步骤。

```
for (var step of iterateJobs(jobs)){
  console.log(step.id);
}
```

上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。

`for...of`的本质是一个`while` 循环,所以上面的代码实质上执行的是下面的逻辑.

```javascript
var it = iterateJobs(jobs);
var res = it.next();
while(!res.done){
  var sesult = res.value;
  //...some code
  res = it.next();
}
```
#### 部署Iterator接口

利用Generator函数,可以在任意对象上部署Iterator接口.

```javascript
function* iterEntries(obj){
  let keys = Object.keys(obj);
  for( let i =0; i < keys.length; i++ ){
    let key = keys[i];
    yield [key,obj[key]];
  }
}

let myobj = {foo:3,bar:7};
for (let [key,value] of iterEntries(myobj)){
  console.log(key,value);
}
//foo 3
//bar 7
let myObjIterator = iterEntries(myobj);
myObjIterator.next();//{value:[foo,3],done:false}
myObjIterator.next();//{value:[bar,7],done:false}
```

`myObj`是一个普通对象,通过`iterEntries`函数,就有了`Iterator`接口,也就是说,可以在任意对象上部署`next`方法

下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。

```javascript
function* makeSimpleGenerator(array){
  var nextIndex = 0;

  while(nextIndex < array.length){
    yield array[nextIndex++];
  }
}

var gen = makeSimpleGenerator(['yo', 'ya']);

gen.next().value // 'yo'
gen.next().value // 'ya'
gen.next().done  // true
```

#### 作为数据结构

Generator可以看作是`数据结构`,更确切地说,可以看作是一个`数组结构`,因为Generator函数可以返回一系列的值,这意味着它可以对任意表达式,提供类似数组的接口

```javascript
function *doStuff() {
  yield fs.readFile.bind(null, 'hello.txt');
  yield fs.readFile.bind(null, 'world.txt');
  yield fs.readFile.bind(null, 'and-such.txt');
}
```

上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。

```javascript
for (task of doStuff()) {
  // task是一个函数，可以像回调函数那样使用它
}
```

实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。

```javascript
function doStuff() {
  return [
    fs.readFile.bind(null, 'hello.txt'),
    fs.readFile.bind(null, 'world.txt'),
    fs.readFile.bind(null, 'and-such.txt')
  ];
}
```

上面的函数，可以用一模一样的`for...of`循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。

#### 小笔记

> 如果想`yield` 后面的方法的return能正确输出,就要将函数变为Generator函数`function*`然后再将`yield`改
>
> 为`yield*` 才会正确的将`return`的值返回,否则将返回一个遍历器对象(`.next()`才是调用)

自己的小demo

```javascript
let steps = [step1Func, step2Func, step3Func];
function* iteratesSteps(steps) {
  var a1 = yield* steps[0]();
  var a2 = yield* steps[1](a1);
  var a3 = yield* steps[2](a2);
}
function* step1Func() {
  return 1
}
function* step2Func(a) {
  console.log(a);
  return a;
}
function* step3Func(a) {
  console.log(a);
  return a;
}
//这里是利用了遍历 将yield都执行了 
for(var i of iteratesSteps(steps)){
  console.log(i);
  //1
  //1
}
//这里是.next()循环调用
let a = iteratesSteps(steps);
var res = a.next();
var v=0;
while(!res.done){
  v +=res.value; 
  res = a.next();
}
```





##  16. Generator 函数的异步应用

### 16.1 传统方法 

ES6 诞生以前,异步编程的方法,大概有下面4种:

- 回调函数
- 事件监听
- 发布/订阅
- Promise对象

Generator函数将js异步变成带入了一个全新的阶段



### 16.2 基本概念

***

#### 16.2.1 异步

所谓'异步',简单来说就是一个任务不是连续完成的,可以理解为任务分成多段,先完成一段,然后执行其他人任务,做好准备以后,再回来执行其他的.

例如`ajax`中,等待数据返回,返回后再执行回调函数,这种不连续的执行,就叫做异步

相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。



####16.2.2 基本概念

##### 回调函数(callback)

JS语言对异步变成的实现,就是回调函数.所谓回调函数,就是把任务的第二段单独写在一个函数里面,等到重新执行这个任务的时候,就直接调用这个函数

```javascript
fs.readFile('/etc/passwd','utf-8',function(err,data){
    if(err) throw err;
  	console.log(data);
});
```

上面代码中,`readFile`函数的第三个参数,就是回调函数,就是任务第二段,等到操作系统返回了`/etc/passwd`这个文件,回调函数才会执行.

Node中约定,回调函数第一个参数,必须是错误对象`err`(如果没有错误,该参数就是` null`)

因为执行分成了两段,第一段执行完成以后,任务所在的上下文环境就已经结束了.在这以后抛出的错误,原来的上下文环境已经无法捕捉到了,只能当作参数,传入第二段,这样才能捕捉到.



##### Promise

回调函数本身并没有问题,它的问题出现在多个回调函数嵌套.假定读取`A`文件之后,在读取`B`文件,

```javascript
fs.readFile(fileA,'utf-8',function(err,data){
    fs.readFile(fileB,'utf-8',function(err,data){
        //...
    })
})
```

可以看出,如果读取两个以上的文件,就会出现多重嵌套.代码不是纵向发展,而是横向发展,很快就会乱成一团,无法管理.因为多个异步操作形成了强耦合,只要有一个操作需要修改,它的上层回调函数和下层回调函数,可能都要跟着修改.这种情况被称为**回调地狱(callback hell)**

Promise对象就是为了解决这个问题而提出的.它不是新的语法功能,而是一种新的写法,允许将回调函数的嵌套,改为链式调用(因为每次都会返回一个Promise对象)

采用Promise,连续读取多个文件

```javascript
var readFile = require('fs-readfile-promise');

readFile(fileA)
.then(function(data){
    console.log(data.toString());
})
.then(function(){
    return readFile(fileB);
})
.then(function(data){
    console.log(data.toString());
})
.catch(function(err){
    console.log(err)
});
```

上面代码使用了`fs-readfile-promise`模块,它的作用就是返回一个Promise版本的`readFile`函数.Promise 提供`then`方法加载回调函数，`catch`方法捕捉执行过程中抛出的错误。

可以看到,Promise的写法只是回调函数的改进,使用`then`方法以后,异步任务的两段执行看的更清楚了,除此以外,并无新意

Promise 的最大问题是代码冗余,原来的任务被Promise包装了一下,不管什么操作,一眼看去都是一堆`then`,原来的语义变得很不清楚.(其实`then`多了之后,或者`then`里面有`then` 还是会造成`回调地狱`)



### 16.3 Generator函数

#### 协程

传统的编程语言,早有异步编程的解决方案(多任务的解决方案)。其中有一种叫做`协程(coroutine)`,意思是多个线程互相协作,完成异步任务.

协程有点像函数,又有点像线程.运行流程大致如下:

- 第一步，协程`A`开始执行。
- 第二步，协程`A`执行到一半，进入暂停，执行权转移到协程`B`。
- 第三步，（一段时间后）协程`B`交还执行权。
- 第四步，协程`A`恢复执行。

上面流程中的协程`A`,就是异步任务,因为它分成两段(或多段)执行.

举例来说,读取文件的协程写法如下

```javascript
function* asyncJob(){
    //...some code
  	var f = yield readFile(fileA);
  	//...some code
}
```

上面代码的函数`asyncJob`是一个协程,它的奥妙就在其中的`yield`命令,它表示执行到此处,执行权将交给其他协程,也就是说,`yield`命令是异步两个阶段的分界线.

协程遇到`yield`命令就暂停,等到执行权返回,再从暂停的地方继续往后执行,它的最大优点,就是代码的写法非常像同步操作,如果去除`yield`命令,就一摸一样了.



#### 协程的Generator 函数实现

Generator函数是在协程在ES6的实现,最大特点就是可以交出函数的执行权(即暂停执行).

整个Generator函数就是一个封装的异步任务,或者说是异步任务的容器.异步操作需要暂停的地方,都用`yield`语句注明,Generator函数执行方法如下:

```javascript
function* gen(x){
    var y = yield x +2;
  	return y;
}
var g = gen (1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```

上面代码中,调用Generator函数,会返回一个内部指针(即遍历器)`g`.这是Generator函数不同于普通函数的另一个地方,即执行它不会返回结果,返回的是指针对象,调用指针`g`的`next`方法,会移动内部指针(即执行异步任务的第一段),指向第一个遇到的`yield`语句,上例是执行到`x+2`为止.

换言之,`next`方法的作用是分阶段执行`Generator`函数.每次调用`next`方法,会返回一个对象,表示当前阶段的信息(`value`属性和`done`属性).`value`属性是`yield`语句后面表达式的值,表示当前阶段的值;`done`属性是一个布尔值,表示Generator函数是否执行完毕,即是否还有下一个阶段.



#### Generator函数的数据交换和错误处理

Generator函数可以暂停执行和恢复执行,这是它能封装异步任务的根本原因,除此之外,它还有两个特性,使它可以作为异步变成的完整解决方案:函数体内外的数据交换和错误处理机制.

`next`返回值的value属性,是Generator函数向外输出数据;`next`方法还可以接受参数,向Generator函数体内输入数据.

```javascript
function* gen(x){
  var y = yield x + 2;
  return y ;
}
var gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
```

上面代码中,第一`next`方法的`value`属性,返回表达式`x + 2`的值`3`.第二个`next`方法带有参数`2`,这个参数可以传入Generator函数,作为上个阶段异步任务的返回结果,被函数体内的变量`y`接收,因此,这一步的`value`属性,返回的就是`2`(变量`y`的值).

`传参可以作为上个阶段异步任务的返回结果`

Generator函数内部还可以部署处理代码,捕获函数体外抛出的错误.

```javascript
function* gen(x){
  try {
      var y = yield x + 2;
  } catch (e){
      console.log(e);
  }
  return y ;
}

var g = gen(1);
g.next();
g.throw('出错了');
//出错了
```

上面代码的最后一行,Generator函数体外,使用指针对象的`throw`方法抛出的错误,可以被函数体内的`try...catch`代码块捕获.这意味着,出错的代码与处理错误的代码,实现了时间和空间上的分离,这对于异步变成无疑是很重要的.



#### 异步任务的封装

```javascript
var fetch = require('node-fetch');

function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}
```

上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了`yield`命令。

执行这段代码:

```javascript
var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
```

`data`是传参,`传参可以作为上个阶段异步任务的返回结果` 传入 result中,result保存

上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用`next`方法（第二行），执行异步任务的第一阶段。由于`Fetch`模块返回的是一个 Promise 对象，因此要用`then`方法调用下一个`next`方法。

可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。



### 16.4 Thunk函数

Thunk函数是自动执行Generator函数的一种方法.



#### 参数的求值策略

一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值。

```javascript
var x = 1;
function f(m){
  reutrn m * 2;
}
f(x + 5);
```

上面代码先定义函数`f`,然后向它传入表达式`x + 5`,请问这个表达式应该何时求值?

一种意见是"传值调用"(call by value),即在进入函数体之前,就计算`x + 5`的值(6),再将这个值传入函数`f`,C语言就采用这种策略。

```javascript
f(x + 5)
// 传值调用时，等同于
f(6)
```

另一种意见是"传名调用"(call by name),即将表达式`x + 5`传入函数体,只在用到它的时候求值.Haskell语言采用这种策略

```javascript
f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
```

传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。

```javascript
function f(a, b){
  return b;
}

f(3 * x * x - 2 * x - 1, x);
```

上面代码中，函数`f`的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。



#### Thunk函数的含义

编译器的"传名调用"实现,往往是将参数放到一个临时函数之中,再将这个临时函数传入函数体,这个临时函数就叫做Thunk 函数.

```javascript
function f(m){
    return m * 2;
}
f(x+5);
//等同于
var thunk = function () {
    return x + 5;
};

function f(thunk) {
    return thunk() * 2;
}
```

上面代码中,函数f的参数`x + 5`被一个函数替换了.凡是用到原参数的地方,对`Thunk`函数求值即可,

这就是Thunk函数的定义,它是"传名调用"的一种实现策略,用来替换某个表达式.

> 就是参数被封装在了一个临时函数里面,这个参数使用时候才调用这个函数,这时才会计算.

#### JavaScript 语言的 Thunk 函数

javaScript语言是传值调用,它的Thunk函数含义有所不同,在JavaScript 语言中,Thunk函数替换的不是表达式,而是多参数函数,将其替换成一个接受回调函数作为参数的单参数函数

```javascript
//正常版本的readFile(多参数版本)
fs.readFile(fileName,callback);

//Thunk 版本的readFile(单参数版本);
var Thunk = function(fileName){
  return function (callback){
    retrun fs.readFile(fileName,callback);
  }
}
var readFileThunk = Thunk(fileName);
redFileThunk(callback);
```

上面代码中,`fs`模块的`readFile`方法是一个多参数函数,两个参数分别为文件名和回调函数.经过转换器处理,它变成了一个单参数函数,只接受回调函数作为参数.这个单参数版本,就叫做Thunk函数

任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。

```javascript
// ES5版本
var Thunk = function(fn){
  return function (){
    var args = Array.prototype.slice.call(arguments);
    return function (callback){
      args.push(callback);
      return fn.apply(this, args);
    }
  };
};

// ES6版本
const Thunk = function(fn) {
  return function (...args) {
    return function (callback) {
      return fn.call(this, ...args, callback);
    }
  };
};
```

使用转换器,生成`fs.readFile`的Thunk函数.

```javascript
var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
```

另一个例子

```javascript
function f(a, cb) {
  cb(a);
}
const ft = Thunk(f);
//转化为
ft = function(...args){
  return function (callback) {
    return fn.call(this, ...args, callback);//fn为function f
}

ft(1)(console.log) // 1
ft(1)//转化为
functiion (callback){
    retrun fn.call(this,1,callback);
}
//再将callback穿进去
fn.call(this, 1, console.log)
//等同于
function f(1,console.log){
    console.log(1);
}();

```

> Thunk作用就是将多参数,转换为单参数的闭包



#### Thunkify 模块

生产环境的转换器,使用Thunkify模块.

```
npm install thunkify
```

使用方式如下.

```javascript
var thunkify =  require('thunkify');
var fs = require('fs');

var read = thunkify(fs.readFile);
read('package.json')(function(err,str){
    // ...some code
});
```

Thunkify源码

```javascript
function thunkify(fn) {
  return function() {
    var args = new Array(arguments.length);
    var ctx = this;

    for (var i = 0; i < args.length; ++i) {
      args[i] = arguments[i];
    }

    return function(done) {
      var called;

      args.push(function() {
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });

      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    };
  };
}
```

比之前的简易版多了一个检查机制,变量`called`确保函数只运行一次,这样的设计与下文的 Generator 函数相关。

```javascript
function f(a,b,callback){
    var sum = a + b;
  	callback(sum);
  	callback(sum);
}
var ft = thunkify(f);
var print = console.log.bind(console);
ft(1, 2)(print);
// 3
```

上面代码中，由于`thunkify`只允许回调函数执行一次，所以只输出一行结果。



#### Generator 函数的流程管理

Thunk 函数现在可以用于 Generator 函数的自动流程管理。

Generator 函数可以自动执行.

```javascript
function* gen(){
    //...
}

var g = gen();
var res = g.next();

while(!res.done){
  console.log(res.value);
  res = g.next();
}
```

上面代码中，Generator 函数`gen`会自动执行完所有步骤。



这不适合异步操作,因为无法保证前一步已经执行完,才执行后一步.上面代码中，Generator 函数`gen`会自动执行完所有步骤。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。

```javascript
var fs = require('fs');
var thunkify = require('thunkify');
var readFileThunk = thunkify(fs.readFile);

var gen = function* (){
  var r1 = yield readFileThunk('/etc/fstab');
  console.log(r1.toString());
  var r2 = yield readFileThunk('/etc/shells');
  console.log(r2.toString());
}
```

上面代码中，`yield`命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。(g.next();)

这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。

```javascript
var g = gen();

var r1 = g.next();
r1.value(function(err,data){
  if(err) throw err;
  var r2 = g.next(data);
  r2.value(function(err,data){
      if(err) throw err;
      g.next(data);
  });
});
```

变量`g`是Generator 函数的内部指针,表示当前执行到哪一步,`next`将指针移动到下一步,并且将该步的信息返回(`value`属性和`done`属性).

 Generator 函数的执行过程，其实是将同一个回调函数，反复传入`next`方法的`value`属性。这使得我们可以用递归来自动完成这个过程。



#### Thunk 函数的自动流程管理

Thunk 函数真正的威力,在于可以自动执行Generator函数.

```javascript
function run(fn) {
    var gen = fn();
  
    function next(err,data){
        var result = gen.next(data);
        if(result.done) return;
      	result.value(next);
    }
   
    next();
}

function* g(){
    //....
}

run(g);
```

`run`函数就是一个 `Generator`函数的自执行器,内部的`next`函数就是 Thunk 的回调函数.首先`next`先移动到Generator函数的下一步,然后判断这个是否结束了(result.done),如果还没结束,就将`next`函数在传入到Thunk函数里面(作为参数传入到`result.value`属性当中,因为里面的是一个`Thunk`所以返回的是一个`Function`,`data`作为参数,传入`Thunk`返回的`Function`当中),否则就退出

有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入`run`函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在`yield`命令后面的必须是 Thunk 函数(就是将一个`多参数`的函数,拆分成一个`单参数多return(return的fn传入另一个参数)`的函数)。

```javascript
var g = function* (){
  var f1 = yield readFileThunk('fileA');
  var f2 = yield readFileThunk('fileB');
  // ...
  var fn = yield readFileThunk('fileN');
};

run(g);
```

上面代码中，函数`g`封装了`n`个异步的读取文件操作，只要执行`run`函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。

Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。



### 16.5 Co模块

#### 基本用法

Generator 函数，用于依次读取两个文件。

```javascript
var gen = function* () {
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
//co 模块可以让你不用编写 Generator 函数的执行器。
var co = require('co');
co(gen);
//co函数返回一个Promise对象，因此可以用then方法添加回调函数。
co(gen).then(function (){
  console.log('Generator 函数执行完成');
});
```

#### Co模块的原理

Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

两种方法可以做到这一点。

（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。

（2）Promise 对象。将异步操作包装成 Promise 对象，用`then`方法交回执行权。

co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的`yield`命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。（co v4.0版以后，`yield`命令后面只能是 Promise 对象，不再支持 Thunk 函数。）



#### 基于Promise 对象的自动执行

首先，把`fs`模块的`readFile`方法包装成一个 Promise 对象。

```javascript
var fs = require('fs');

var readFile = function (fileName){
    return new Promise(function(resolve,reject){
        fs.readFile(fileName,function(error,data){
            if(error) return reject(error);
          	resolve(data);
        });
    });
};

var gen = function* (){
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};

//手动执行
var g =gen();
g.next().value.then(function(data){
    g.next(data).value.then(function(data){
        g.next(data);
    })
}
```

手动执行其实就是用`then`方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。用`then`代替了`Thunk`函数回调的方法

```javascript
function run(gen){
    var g = gen();
  	function next(data){
        var result = g.next(data);
      	if(result.done) return result.value;
      	result.value.then(function(data){
            next(data);
        });
    }
  	next();
}
run(gen);
```

> 其实和`THUNK`的run基本一致,实现方法改变了而已

只要 Generator 函数还没执行到最后一步，`next`函数就调用自身，以此实现自动执行。



#### co模块的源码

```javascript
//首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。
function co(gen){
    var ctx = this;
  	return new Promise(function(resolve,rejcet){});
}

//在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。
function co(gen){
    var ctx = this;
  	return new Promise(function(resolve,rejcet){
        if(typeof gen === 'function') gen = gen.call(ctx);
      	if(!gen||typeof gen.next !=='function') return resolve(gen);
    });
}

//接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。
function co(gen){
    var ctx = this;
  	return new Promise(function(resolve,rejcet){
        if(typeof gen === 'function') gen = gen.call(ctx);
      	if(!gen||typeof gen.next !=='function') return resolve(gen);
      
      	onFulfilled();
      	function onFulfilled(res){
            var ret;
          	try{
                ret = gen.next(res);
            } catch(e){
                return reject(e);
            }
          	next(ret);
        }
    });
}
// 最后，就是关键的next函数，它会反复调用自身。
// 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。
// 第二行，确保每一步的返回值，是 Promise 对象。
// 第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。
// 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。
第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。
function co(gen){
    var ctx = this;
  	return new Promise(function(resolve,rejcet){
        if(typeof gen === 'function') gen = gen.call(ctx);
      	if(!gen||typeof gen.next !=='function') return resolve(gen);
      
      	onFulfilled();
      	function onFulfilled(res){
            var ret;
          	try{
                ret = gen.next(res);
            } catch(e){
                return reject(e);
            }
          	next(ret);
        }
      	function next(ret){
          // 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。
          if(ret.done) return resolve(ret.value);
          // 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。
          var value = toPromise.call(ctx,ret.value);
          // 第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。
          if(value && isPromise(value)) return value.then(onFulfilled,onRejected);
          // 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的              状态改为rejected，从而终止执行。
          return onRejected(
            new TypeError(
              'You may only yield a function, promise, generator, array, or object, '
              + 'but the following object was passed: "'
              + String(ret.value)
              + '"'
            )
          );
        }
    });
}
```



#### 处理并发的异步操作

co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。

这时，要把并发的操作都放在数组或对象里面，跟在`yield`语句后面。

```javascript
//数组的写法
co(function* (){
  var res = yield [
      Promise.resolve(1),
      Promise.resolve(2)
  ];
  console.log(res);
}).catch(onerror);

//对象写法
co(function* (){
  var res = yield {
    1:Promise.resolve(1),
    2:Promise.resolve(2)
  };
  console.log(res);
}).catch(onerror)
```

```javascript
co(function* () {
  var values = [n1, n2, n3];
  yield values.map(somethingAsync);
});

function* somethingAsync(x) {
  // do something async
  return y
}
```

上面的代码允许并发三个`somethingAsync`异步操作，等到它们全部完成，才会进行下一步。

#### 实例：处理 Stream

Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。

- `data`事件：下一块数据块已经准备好了。
- `end`事件：整个“数据流”处理“完了。
- `error`事件：发生错误。

使用`Promise.race()`函数，可以判断这三个事件之中哪一个最先发生，只有当`data`事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个`while`循环，完成所有数据的读取。

```javascript
const co = require('co');
const fs = require('fs');

const stream = fs.createReadStream('./les_miserables.txt');
let valjeanCount = 0;

co(function*() {
  while(true) {
    const res = yield Promise.race([
      new Promise(resolve => stream.once('data', resolve)),
      new Promise(resolve => stream.once('end', resolve)),
      new Promise((resolve, reject) => stream.once('error', reject))
    ]);
    if (!res) {
      break;
    }
    stream.removeAllListeners('data');
    stream.removeAllListeners('end');
    stream.removeAllListeners('error');
    valjeanCount += (res.toString().match(/valjean/ig) || []).length;
  }
  console.log('count:', valjeanCount); // count: 1120
});
```

上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用`stream.once`方法，在`data`、`end`、`error`三个事件上添加一次性回调函数。变量`res`只有在`data`事件发生时才有值，然后累加每个数据块之中`valjean`这个词出现的次数。





## 17.Async 函数

### 17.1 含义

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

```javascript
//依次读取两个文件
const fs = require('fs');

const readFile = function (fileName) {
    return new Promise(function(resolve,reject){
        fs.readFile(fileName,function(error,data){
            if (error) return reject(error);
          	resolve(data);
        });
    });
};

//之前的方式
const gen = function* (){
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
}
//执行的话要
var g =gen();
g.next();
//或者使用co
co(gen);
co(gen).then(
  function(){//..somecode
  });

//写成
const asyncReadFile = async function (){
	const f1 = await readFile('/etc/fstab');
  	const f2 = await readFile('/etc/shells');
    console.log(f1.toString());
  	console.log(f2.toString());
};
```

`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`。

`async`函数对 Generator 函数的改进，体现在以下四点。



(1) 内置执行器

Generator函数的执行必须靠执行器(g.next()),所以有了`co`模块,而`async`函数里有自带执行器,也就是说`async`函数的执行,与普通函数一摸一样,只需要一行.

```javascript
asyncReadFile();
```

调用后,就会自动执行,输出最后结果.这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。



(2) 更好的语义

`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。



(3) 更广的适用性

`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象(4.0之后只能是Promise)，而`async`函数的`await`命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。



(4) 返回值是Promise

`async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。可以用`then`方法指定下一步的操作。



进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。



### 17.2 基本用法

`async`函数返回一个Promise对象,可以使用`then`方法添加回调函数。

当函数执行的时候，一旦遇到`await`就会返回,等到异步操作完成,(交回制定权),再接着执行函数体内后面的语句.

```javascript
async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPriceByName(symbol);
  return stockPrice;
}
getStockPriceByName("goog").then(function(reslt) {
  console.log(result);
});
```

函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。

下面是另一个例子，指定多少毫秒后输出一个值。

```javascript
function timeout(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}
asyncPrint("hello world", 50);
```

由于`async`函数返回的是 Promise 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。

```javascript
async function timeout(ms) {
  await new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}

asyncPrint("hello world", 50);
```

async 函数有多种使用形式。

```javascript
// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open('avatars');
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar('jake').then(…);

// 箭头函数
const foo = async () => {};
```

